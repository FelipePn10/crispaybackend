// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: verification_sessions.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createVerificationSession = `-- name: CreateVerificationSession :one
INSERT INTO verification_sessions (
    user_id,
    session_id,
    didit_session_id,
    verification_url,
    user_email,
    user_first_name,
    user_last_name,
    status
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata
`

type CreateVerificationSessionParams struct {
	UserID          string
	SessionID       string
	DiditSessionID  sql.NullString
	VerificationUrl sql.NullString
	UserEmail       string
	UserFirstName   sql.NullString
	UserLastName    sql.NullString
	Status          string
}

func (q *Queries) CreateVerificationSession(ctx context.Context, arg CreateVerificationSessionParams) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, createVerificationSession,
		arg.UserID,
		arg.SessionID,
		arg.DiditSessionID,
		arg.VerificationUrl,
		arg.UserEmail,
		arg.UserFirstName,
		arg.UserLastName,
		arg.Status,
	)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const createWebhookEvent = `-- name: CreateWebhookEvent :one
INSERT INTO webhook_events (
    event_type,
    session_id,
    payload
) VALUES ($1, $2, $3)
RETURNING id, event_type, session_id, payload, processed, created_at
`

type CreateWebhookEventParams struct {
	EventType string
	SessionID string
	Payload   json.RawMessage
}

func (q *Queries) CreateWebhookEvent(ctx context.Context, arg CreateWebhookEventParams) (WebhookEvent, error) {
	row := q.db.QueryRowContext(ctx, createWebhookEvent, arg.EventType, arg.SessionID, arg.Payload)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.SessionID,
		&i.Payload,
		&i.Processed,
		&i.CreatedAt,
	)
	return i, err
}

const getVerificationSessionByDiditSessionID = `-- name: GetVerificationSessionByDiditSessionID :one
SELECT id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata FROM verification_sessions 
WHERE didit_session_id = $1 LIMIT 1
`

func (q *Queries) GetVerificationSessionByDiditSessionID(ctx context.Context, diditSessionID sql.NullString) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, getVerificationSessionByDiditSessionID, diditSessionID)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getVerificationSessionByID = `-- name: GetVerificationSessionByID :one
SELECT id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata FROM verification_sessions 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVerificationSessionByID(ctx context.Context, id uuid.UUID) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, getVerificationSessionByID, id)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getVerificationSessionBySessionID = `-- name: GetVerificationSessionBySessionID :one
SELECT id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata FROM verification_sessions 
WHERE session_id = $1 LIMIT 1
`

func (q *Queries) GetVerificationSessionBySessionID(ctx context.Context, sessionID string) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, getVerificationSessionBySessionID, sessionID)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getWebhookEventsBySessionID = `-- name: GetWebhookEventsBySessionID :many
SELECT id, event_type, session_id, payload, processed, created_at FROM webhook_events 
WHERE session_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetWebhookEventsBySessionID(ctx context.Context, sessionID string) ([]WebhookEvent, error) {
	rows, err := q.db.QueryContext(ctx, getWebhookEventsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookEvent
	for rows.Next() {
		var i WebhookEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.SessionID,
			&i.Payload,
			&i.Processed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationSessionsByStatus = `-- name: ListVerificationSessionsByStatus :many
SELECT id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata FROM verification_sessions 
WHERE status = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationSessionsByStatus(ctx context.Context, status string) ([]VerificationSession, error) {
	rows, err := q.db.QueryContext(ctx, listVerificationSessionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationSession
	for rows.Next() {
		var i VerificationSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.Status,
			&i.DiditSessionID,
			&i.VerificationUrl,
			&i.UserEmail,
			&i.UserFirstName,
			&i.UserLastName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVerificationSessionsByUserID = `-- name: ListVerificationSessionsByUserID :many
SELECT id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata FROM verification_sessions 
WHERE user_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListVerificationSessionsByUserID(ctx context.Context, userID string) ([]VerificationSession, error) {
	rows, err := q.db.QueryContext(ctx, listVerificationSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VerificationSession
	for rows.Next() {
		var i VerificationSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.Status,
			&i.DiditSessionID,
			&i.VerificationUrl,
			&i.UserEmail,
			&i.UserFirstName,
			&i.UserLastName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDiditSessionData = `-- name: UpdateDiditSessionData :one
UPDATE verification_sessions 
SET 
    didit_session_id = $2,
    verification_url = $3,
    updated_at = NOW()
WHERE session_id = $1
RETURNING id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata
`

type UpdateDiditSessionDataParams struct {
	SessionID       string
	DiditSessionID  sql.NullString
	VerificationUrl sql.NullString
}

func (q *Queries) UpdateDiditSessionData(ctx context.Context, arg UpdateDiditSessionDataParams) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, updateDiditSessionData, arg.SessionID, arg.DiditSessionID, arg.VerificationUrl)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const updateVerificationSessionStatus = `-- name: UpdateVerificationSessionStatus :one
UPDATE verification_sessions 
SET 
    status = $2,
    updated_at = NOW(),
    completed_at = CASE 
        WHEN $2 IN ('approved', 'rejected', 'failed') THEN NOW() 
        ELSE completed_at 
    END
WHERE session_id = $1
RETURNING id, user_id, session_id, status, didit_session_id, verification_url, user_email, user_first_name, user_last_name, created_at, updated_at, completed_at, metadata
`

type UpdateVerificationSessionStatusParams struct {
	SessionID string
	Status    string
}

func (q *Queries) UpdateVerificationSessionStatus(ctx context.Context, arg UpdateVerificationSessionStatusParams) (VerificationSession, error) {
	row := q.db.QueryRowContext(ctx, updateVerificationSessionStatus, arg.SessionID, arg.Status)
	var i VerificationSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.Status,
		&i.DiditSessionID,
		&i.VerificationUrl,
		&i.UserEmail,
		&i.UserFirstName,
		&i.UserLastName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}
